usethis::use_gpl3_license()
?lattice
?ggplot
help(ggplot)
??ggplot
??
library(MCMCMixBimodal)
MCMCmixtureGaussian
help("MCMCMixBimodal.MCMCmixtureGaussian")
??MCMCMixBimodal.MCMCmixtureGaussian
?MCMCmixtureGaussian
?MCMCmixtureGaussian
?mean
getAnywhere(mean)
rm(list = ls())
rm(list = ls())
library(MCMCMixBimodal)
?MCMCmixtureGaussian
?ggplot2
library(MCMCMixBimodal)
library(roxygen2)
install.packages("roxygen2")
library(roxygen2)
library(MCMCMixBimodal)
help("MCMCmixtureGaussian")
help("MCMCmixtureGaussian")
library(MCMCMixBimodal)
help(MCMCMixtureGaussian)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
help("MCMCmixtureGaussian")
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
x = 2
mean1 = 1
mean2 = 10
var1 = 2
var2 = 3
alpha = 0.3
Nsim = 1000
mean11 = min(mean1, mean2)
mean22 = max(mean1, mean2)
n=1000                              # declared number of replications of the chain
X=rep(0, times=Nsim)                #initialized vector to store chain values
Z=do.call("rbind",replicate(n, chain(mean11, mean1, mean2, var1, var2, alpha, Nsim), simplify = F))
target_density <- function(x, mean1, mean2, var1, var2, alpha)
{
W= alpha * dnorm(x, mean1, var1)
V=(1- alpha)*dnorm(x, mean2 ,var2)
return(W+V)
}
chain <- function(t, mean1, mean2, var1, var2, alpha, Nsim)
{
X = c()
mean11 = min(mean1, mean2)
mean22 = max(mean1, mean2)
X[1]=t                  #Initialized the chain
for(i in 2:Nsim)
{
# Code for Proposal Density
W=rnorm(1,( alpha * mean22) + ((1 - alpha) * X[i-1]), 5)
V=rnorm(1,(alpha * mean11) + ((1 - alpha) * X[i-1]), 5)
# Adjusting the proposal density based on the location of the previously iterated value
if(abs(X[i-1] - mean11) < abs(X[i-1] - mean22))
{
Y=W
}
else
{
Y=V
}
rho = target_density(Y, mean1, mean2, var1, var2, alpha) / target_density(X[i-1], mean1, mean2, var1, var2, alpha)    # defined the rate parameter for Metropolis Hastings Algorithm
# stored the next iterated value of the chain
if(runif(1) < rho)
{
X[i] = Y
}
else
{
X[i] = X[i-1]
}
}
return(X)
}
Z=do.call("rbind",replicate(n, chain(mean11, mean1, mean2, var1, var2, alpha, Nsim), simplify = F))
R=Z[,2]
R=Z[, 500]
#histogram of generated values along with the density curve
hist(R, breaks=70, prob=T)
curve(target_density(x), mean11 - 3*var1, mean22 + 3*var2, add=T)
curve(target_density(x, mean1, mean2, var1, var2, alpha), mean11 - 3*var1, mean22 + 3*var2, add=T)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
install.packages("devtools")
library(devtools)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
usethis::use_import_from("stats")
usethis::use_package("stats", type = "Imports")
usethis::use_package("graphics", type = "Imports")
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
help("MCMCmixtureGaussian")
MCMCmixtureGaussian(1, 10, 2, 3, 0.3, 1000)
library(MCMCMixBimodal)
install.packages(c("usethis", "roxygen2", "devtools"))
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
styler:::style_active_file()
styler:::style_active_file()
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
