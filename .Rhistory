E[i]=i/n
}
O=c()
for(i in 1:n)
{
x = V[i]
O[i]=abs(E[i]- ((alpha * pnorm(x, mean1, var1))+((1 - alpha) * pnorm(x, mean2, var2))) )
}
M=max(O)
S[j]=M
}
plot(S)
}
MCMCrateGaussian(mean1 = 0, mean2 = 20, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
source(here::here("R", "MCMCmixtureGaussian.R"))
#' MCMC rate Gaussian
#'
#'
#' MCMCrateGaussian generate 500 Markov Chain values simultaneously
#' at each iteration of the Algorithm. As its output, it will return the curve of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#'
#' @param mean1 mean of 1st univariate gaussian distribution
#' @param mean2 mean of 2nd univariate gaussian distribution
#' @param var1  variance of 1st univariate gaussian distribution
#' @param var2  variance of 2nd univariate gaussian distribution
#' @param alpha value of mixing parameter
#' @param Nsim  number of values to be simulated from the mixture distribution
#'
#' @return plot of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#' @export
#'
#' @examples MCMCrateGaussian(mean1, mean2, var1, var2, alpha, Nsim)
#'
#'
MCMCrateGaussian <- function(mean1, mean2, var1, var2, alpha, Nsim) {
n = 50
S=c()
Z=do.call("rbind",replicate(n,chain(mean1, mean1, mean2, var1, var2, alpha, Nsim), simplify = F))
for(j in 1:n)
{
P=Z[,j]
V=sort(P)
E=c()
for(i in 1:n)
{
E[i]=i/n
}
O=c()
for(i in 1:n)
{
x = V[i]
O[i]=abs(E[i]- ((alpha * pnorm(x, mean1, var1))+((1 - alpha) * pnorm(x, mean2, var2))) )
}
M=max(O)
S[j]=M
}
plot(S)
}
MCMCrateGaussian(mean1 = 0, mean2 = 20, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
f <- function(x)
{
W=0.5*dnorm(x,0,1)
V=(1-0.5)*dnorm(x,20,2)
return(W+V)
}
curve(f(x), -10, 30)
Nsim=500
n=1000
X=rep(0, times=Nsim)
h <- function(t)
{
X[1]=t
for(i in 2:Nsim)
{
W=rnorm(1,(0.99*20)+(0.01*X[i-1]),5)
V=rnorm(1,(0.99*0)+(0.01*X[i-1]),5)
if(abs(X[i-1]-0)<abs(X[i-1]-20))
{
Y=W
}
else
{
Y=V
}
rho=f(Y)/f(X[i-1])
if(runif(1) < rho)
{
X[i]=Y
}
else
{
X[i]=X[i-1]
}
}
return(X)
}
Z=do.call("rbind",replicate(n,h(0), simplify = F))
R=Z[,500]
hist(R, breaks=70, prob=T)
curve(f(x), -4,30, add=T)
S=c()
h <- function(x)
{
return((0.5*pnorm(x))+(0.5*pnorm(x,20,2)))
}
# h <- function(x, alpha, mean1, mean2, var1, var2)
# {
#   return((alpha * pnorm(x, mean1, var1))+( (1 - alpha) *pnorm(x, mean2, var2)))
# }
#
for(j in 1:50)
{
P=Z[,j]
V=sort(P)
E=c()
for(i in 1:n)
{
E[i]=i/n
}
O=c()
for(i in 1:n)
{
O[i]=abs(E[i]-h(V[i]))
}
M=max(O)
S[j]=M
}
# plot(Z[,10],O)
plot(S)
source(here::here("R", "MCMCmixtureGaussian.R"))
#' MCMC rate Gaussian
#'
#'
#' MCMCrateGaussian generate 500 Markov Chain values simultaneously
#' at each iteration of the Algorithm. As its output, it will return the curve of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#'
#' @param mean1 mean of 1st univariate gaussian distribution
#' @param mean2 mean of 2nd univariate gaussian distribution
#' @param var1  variance of 1st univariate gaussian distribution
#' @param var2  variance of 2nd univariate gaussian distribution
#' @param alpha value of mixing parameter
#' @param Nsim  number of values to be simulated from the mixture distribution
#'
#' @return plot of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#' @export
#'
#' @examples MCMCrateGaussian(mean1, mean2, var1, var2, alpha, Nsim)
#'
#'
MCMCrateGaussian <- function(mean1, mean2, var1, var2, alpha, Nsim) {
n = 50
S=c()
Z=do.call("rbind",replicate(n,chain(mean1, mean1, mean2, var1, var2, alpha, Nsim), simplify = F))
for(j in 1:n)
{
P=Z[,j]
V=sort(P)
E=c()
for(i in 1:n)
{
E[i]=i/n
}
O=c()
for(i in 1:n)
{
x = V[i]
O[i]=abs(E[i]- ((alpha * pnorm(x, mean1, var1))+((1 - alpha) * pnorm(x, mean2, var2))) )
}
M=max(O)
S[j]=M
}
plot(S)
}
MCMCrateGaussian(mean1 = 0, mean2 = 20, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
source(here::here("R", "MCMCmixtureGaussian.R"))
#' MCMC rate Gaussian
#'
#'
#' MCMCrateGaussian generate 500 Markov Chain values simultaneously
#' at each iteration of the Algorithm. As its output, it will return the curve of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#'
#' @param mean1 mean of 1st univariate gaussian distribution
#' @param mean2 mean of 2nd univariate gaussian distribution
#' @param var1  variance of 1st univariate gaussian distribution
#' @param var2  variance of 2nd univariate gaussian distribution
#' @param alpha value of mixing parameter
#' @param Nsim  number of values to be simulated from the mixture distribution
#'
#' @return plot of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#' @export
#'
#' @examples MCMCrateGaussian(mean1, mean2, var1, var2, alpha, Nsim)
#'
#'
MCMCrateGaussian <- function(mean1, mean2, var1, var2, alpha, Nsim) {
n = 1000
S=c()
Z=do.call("rbind",replicate(n,chain(mean1, mean1, mean2, var1, var2, alpha, Nsim), simplify = F))
for(j in 1: 50)
{
P=Z[,j]
V=sort(P)
E=c()
for(i in 1:n)
{
E[i]=i/n
}
O=c()
for(i in 1:n)
{
x = V[i]
O[i]=abs(E[i]- ((alpha * pnorm(x, mean1, var1))+((1 - alpha) * pnorm(x, mean2, var2))) )
}
M=max(O)
S[j]=M
}
plot(S)
}
MCMCrateGaussian(mean1 = 0, mean2 = 20, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
MCMCrateGaussian(mean1 = 20, mean2 = 0, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
# source(here::here("R", "MCMCmixtureGaussian.R"))
target_density <- function(x, mean1, mean2, var1, var2, alpha) {
W <- alpha * stats::dnorm(x, mean1, var1)
V <- (1 - alpha) * stats::dnorm(x, mean2, var2)
return(W + V)
}
chain <- function(t, mean1, mean2, var1, var2, alpha, Nsim) {
X <- rep(0, Nsim)
mean11 <- min(mean1, mean2)
mean22 <- max(mean1, mean2)
if(mean1 == mean1){
var11 <- var1
var22 <- var2
}else{
var11 <- var2
var22 <- var1
}
X[1] <- t # Initialized the chain
for (i in 2:Nsim)
{
# Code for Proposal Density
W <- stats::rnorm(1, (alpha * mean22) + ((1 - alpha) * X[i - 1]), var2 +  10)
V <- stats::rnorm(1, (alpha * mean11) + ((1 - alpha) * X[i - 1]), var1 + 10)
# Adjusting the proposal density based on the location of the previously iterated value
if (abs(X[i - 1] - mean11) < abs(X[i - 1] - mean22)) {
Y <- W
} else {
Y <- V
}
rho <- target_density(Y, mean1, mean2, var1, var2, alpha) / target_density(X[i - 1], mean1, mean2, var1, var2, alpha) # defined the rate parameter for Metropolis Hastings Algorithm
# stored the next iterated value of the chain
if (stats::runif(1) < rho) {
X[i] <- Y
} else {
X[i] <- X[i - 1]
}
}
return(X)
}
#' MCMC rate Gaussian
#'
#'
#' MCMCrateGaussian generate 500 Markov Chain values simultaneously
#' at each iteration of the Algorithm. As its output, it will return the curve of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#'
#' @param mean1 mean of 1st univariate gaussian distribution
#' @param mean2 mean of 2nd univariate gaussian distribution
#' @param var1  variance of 1st univariate gaussian distribution
#' @param var2  variance of 2nd univariate gaussian distribution
#' @param alpha value of mixing parameter
#' @param Nsim  number of values to be simulated from the mixture distribution
#'
#' @return plot of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#' @export
#'
#' @examples MCMCrateGaussian(mean1, mean2, var1, var2, alpha, Nsim)
#' MCMCrateGaussian(mean1 = 20, mean2 = 0, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
#'
MCMCrateGaussian <- function(mean1, mean2, var1, var2, alpha, Nsim) {
n = 1000
S=c()
Z=do.call("rbind",replicate(n, chain( t = mean1, mean1 = mean1, mean2 = mean2, var1 = var1, var2 = var2, alpha = alpha, Nsim = Nsim), simplify = F))
for(j in 1: 50)
{
P=Z[,j]
V=sort(P)
E=c()
for(i in 1:n)
{
E[i]=i/n
}
O=c()
for(i in 1:n)
{
x = V[i]
O[i]=abs(E[i]- ((alpha * stats::pnorm(x, mean1, var1))+((1 - alpha) * stats::pnorm(x, mean2, var2))) )
}
M=max(O)
S[j]=M
}
plot(S)
}
MCMCrateGaussian(mean1 = 20, mean2 = 0, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
library(MCMCMixBimodal)
# source(here::here("R", "MCMCmixtureGaussian.R"))
#' MCMC rate Gaussian
#'
#'
#' MCMCrateGaussian generate 500 Markov Chain values simultaneously
#' at each iteration of the Algorithm. As its output, it will return the curve of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#'
#' @param mean1 mean of 1st univariate gaussian distribution
#' @param mean2 mean of 2nd univariate gaussian distribution
#' @param var1  variance of 1st univariate gaussian distribution
#' @param var2  variance of 2nd univariate gaussian distribution
#' @param alpha value of mixing parameter
#' @param Nsim  number of values to be simulated from the mixture distribution
#'
#' @return plot of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#' @export
#'
#' @examples
#' MCMCrateGaussian(mean1 = 20, mean2 = 0, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
#'
MCMCrateGaussian <- function(mean1, mean2, var1, var2, alpha, Nsim) {
n = 1000
S=c()
Z <- do.call("rbind", replicate(n, MCMCmixtureGaussian::chain(mean1, mean1, mean2, var1, var2, alpha, Nsim), simplify = F))
# Z=do.call("rbind",replicate(n, chain( t = mean1, mean1 = mean1, mean2 = mean2, var1 = var1, var2 = var2, alpha = alpha, Nsim = Nsim), simplify = F))
for(j in 1: 50)
{
P=Z[,j]
V=sort(P)
E=c()
for(i in 1:n)
{
E[i]=i/n
}
O=c()
for(i in 1:n)
{
x = V[i]
O[i]=abs(E[i]- ((alpha * stats::pnorm(x, mean1, var1))+((1 - alpha) * stats::pnorm(x, mean2, var2))) )
}
M=max(O)
S[j]=M
}
plot(S)
}
MCMCrateGaussian(mean1 = 20, mean2 = 0, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
# source(here::here("R", "MCMCmixtureGaussian.R"))
#' MCMC rate Gaussian
#'
#'
#' MCMCrateGaussian generate 500 Markov Chain values simultaneously
#' at each iteration of the Algorithm. As its output, it will return the curve of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#'
#' @param mean1 mean of 1st univariate gaussian distribution
#' @param mean2 mean of 2nd univariate gaussian distribution
#' @param var1  variance of 1st univariate gaussian distribution
#' @param var2  variance of 2nd univariate gaussian distribution
#' @param alpha value of mixing parameter
#' @param Nsim  number of values to be simulated from the mixture distribution
#'
#' @return plot of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#' @export
#'
#' @examples
#' MCMCrateGaussian(mean1 = 20, mean2 = 0, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
#'
MCMCrateGaussian <- function(mean1, mean2, var1, var2, alpha, Nsim) {
n = 1000
S=c()
Z <- do.call("rbind", replicate(n, MCMCMixBimodal::MCMCmixtureGaussian()::chain(mean1, mean1, mean2, var1, var2, alpha, Nsim), simplify = F))
# source(here::here("R", "MCMCmixtureGaussian.R"))
#' MCMC rate Gaussian
#'
#'
#' MCMCrateGaussian generate 500 Markov Chain values simultaneously
#' at each iteration of the Algorithm. As its output, it will return the curve of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#'
#' @param mean1 mean of 1st univariate gaussian distribution
#' @param mean2 mean of 2nd univariate gaussian distribution
#' @param var1  variance of 1st univariate gaussian distribution
#' @param var2  variance of 2nd univariate gaussian distribution
#' @param alpha value of mixing parameter
#' @param Nsim  number of values to be simulated from the mixture distribution
#'
#' @return plot of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#' @export
#'
#' @examples
#' MCMCrateGaussian(mean1 = 20, mean2 = 0, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
#'
MCMCrateGaussian <- function(mean1, mean2, var1, var2, alpha, Nsim) {
n = 1000
S=c()
Z <- do.call("rbind", replicate(n, MCMCMixBimodal::chain(mean1, mean1, mean2, var1, var2, alpha, Nsim), simplify = F))
# Z=do.call("rbind",replicate(n, chain( t = mean1, mean1 = mean1, mean2 = mean2, var1 = var1, var2 = var2, alpha = alpha, Nsim = Nsim), simplify = F))
for(j in 1: 50)
{
P=Z[,j]
V=sort(P)
E=c()
for(i in 1:n)
{
E[i]=i/n
}
O=c()
for(i in 1:n)
{
x = V[i]
O[i]=abs(E[i]- ((alpha * stats::pnorm(x, mean1, var1))+((1 - alpha) * stats::pnorm(x, mean2, var2))) )
}
M=max(O)
S[j]=M
}
plot(S)
}
MCMCrateGaussian(mean1 = 20, mean2 = 0, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
remove.packages("MCMCMixBimodal")
# source(here::here("R", "MCMCmixtureGaussian.R"))
#' MCMC rate Gaussian
#'
#'
#' MCMCrateGaussian generate 500 Markov Chain values simultaneously
#' at each iteration of the Algorithm. As its output, it will return the curve of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#'
#' @param mean1 mean of 1st univariate gaussian distribution
#' @param mean2 mean of 2nd univariate gaussian distribution
#' @param var1  variance of 1st univariate gaussian distribution
#' @param var2  variance of 2nd univariate gaussian distribution
#' @param alpha value of mixing parameter
#' @param Nsim  number of values to be simulated from the mixture distribution
#'
#' @return plot of supremum of the absolute
#' difference between the empirical CDF of the 500 generated values of the chain and the actual CDF of the
#' target distribution at each iteration.
#' @export
#'
#' @examples
#' MCMCrateGaussian(mean1 = 20, mean2 = 0, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
#'
MCMCrateGaussian <- function(mean1, mean2, var1, var2, alpha, Nsim) {
n = 1000
S=c()
Z <- do.call("rbind", replicate(n, MCMCMixBimodal::chain(mean1, mean1, mean2, var1, var2, alpha, Nsim), simplify = F))
# Z=do.call("rbind",replicate(n, chain( t = mean1, mean1 = mean1, mean2 = mean2, var1 = var1, var2 = var2, alpha = alpha, Nsim = Nsim), simplify = F))
for(j in 1: 50)
{
P=Z[,j]
V=sort(P)
E=c()
for(i in 1:n)
{
E[i]=i/n
}
O=c()
for(i in 1:n)
{
x = V[i]
O[i]=abs(E[i]- ((alpha * stats::pnorm(x, mean1, var1))+((1 - alpha) * stats::pnorm(x, mean2, var2))) )
}
M=max(O)
S[j]=M
}
plot(S)
}
MCMCrateGaussian(mean1 = 20, mean2 = 0, var1= 1, var2 = 2, alpha= 0.5, Nsim= 1000)
library(MCMCMixBimodal)
# source(here::here("R", "MCMCmixtureGaussian.R"))
load_all()
rm(list = c("chain", "MCMCmixtureGaussian",
"target_density"))
library(MCMCMixBimodal)
library(MCMCMixBimodal)
